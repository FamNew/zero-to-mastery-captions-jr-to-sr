WEBVTT

00:01.700 --> 00:03.920
Hey there it's Bruno here.

00:03.920 --> 00:06.170
This is absolutely fantastic.

00:06.170 --> 00:11.420
I've reported some of your findings to our CEO and we're very confident that we're going to be able

00:11.420 --> 00:16.770
to scale this company and manage all the users that we're going to have as we grow and grow more.

00:16.790 --> 00:20.450
Really appreciate you're doing fantastic work.

00:20.450 --> 00:22.010
Hey take a break.

00:22.010 --> 00:22.970
I'll see you tomorrow.

00:25.050 --> 00:25.840
All right.

00:25.920 --> 00:31.250
We have just completed our entire picture of how to optimize performance.

00:31.260 --> 00:38.190
I want you to use this slide as a reference any time you're asked or you're looking to improve performance

00:38.370 --> 00:39.710
on your application.

00:39.810 --> 00:43.790
Look at this and see where you will have the biggest impact.

00:43.800 --> 00:51.060
Start with the easiest when like minimizing files or using it and then move on to more complicated tasks

00:51.060 --> 00:58.500
like figuring out the best way to improve your critical rendering path to even load balancing.

00:58.570 --> 01:08.220
And I hope you have fun up to this point because you see you've learned how to make projects and applications

01:08.280 --> 01:09.050
better.

01:09.300 --> 01:16.330
You learned about re-act him redux how these Front-End libraries make making fast scalable Front-End

01:16.380 --> 01:18.640
applications work really well.

01:19.360 --> 01:24.520
We also learned about securing our applications whether we should use Kline's side rendering or server

01:24.520 --> 01:25.520
side rendering.

01:25.540 --> 01:31.480
We obviously learned about performance type checking and how to write unit tests all things that make

01:31.480 --> 01:39.100
us better software developers things that improve software and that make our bosses clients customers

01:39.130 --> 01:41.450
happy.

01:41.670 --> 01:48.990
And we've also learned how to handle the entire architecture of an app for example with our smart brain

01:48.990 --> 01:49.340
app.

01:49.410 --> 01:53.540
We're able to create a single page application using react.

01:53.610 --> 01:56.600
We served a shemale CSSA and javascript files.

01:56.850 --> 02:05.220
We used Ada Publius lambda to do some tasks run simple functions for us through Amazon's servers.

02:05.220 --> 02:14.070
We used a node API server using Express to talk to clarify API and get the response of our images.

02:14.370 --> 02:20.680
We use postscripts to manage our database of users and log in information.

02:20.700 --> 02:28.410
We also used Pretis for fast memory storage to manage our sessions and make sure that we have protected

02:28.410 --> 02:34.090
routes so that only authenticated users can access private information.

02:34.410 --> 02:40.290
We learned how to add docker containers to the entire system to make life simpler for us and we even

02:40.290 --> 02:45.940
learned how to S-sh into these services so we can debug them and check out their logs.

02:45.990 --> 02:53.520
And now you have a better picture of how you might want to scale or improve our apps as they grow and

02:53.520 --> 02:55.840
grow to millions of users.

02:55.980 --> 03:02.130
We can add whatever functions that are expensive or we don't want to bother in our server to something

03:02.130 --> 03:10.830
like slamdunk having a service architecture where we run these functions in containers on Amazon whenever

03:10.830 --> 03:11.580
they need it.

03:11.640 --> 03:14.540
If we have something that's seasonal that has high peaks.

03:14.620 --> 03:17.550
Well Amazon's going to take care of it for us.

03:17.580 --> 03:23.940
We can use something like load balancing to have multiple API servers to manage all the requests that

03:24.030 --> 03:26.490
users my half.

03:26.640 --> 03:32.940
We can run these servers in Dakar containers so we can just deploy them and replicate them in any hosted

03:33.390 --> 03:33.970
machine.

03:35.150 --> 03:41.870
We can improve our databases by perhaps having cached information and read us or perhaps even duplicating

03:42.110 --> 03:45.200
databases so we have more power.

03:45.500 --> 03:51.590
And then we also have arrests and how we can once again create multiple rattus instances to manage our

03:51.590 --> 03:58.470
data store our session information or perhaps even store some cached information from databases.

03:59.380 --> 04:05.800
And if you look at this diagram and it makes sense to you and you see how bits and pieces can be improved

04:05.800 --> 04:09.120
upon and added upon as are your application grow.

04:09.340 --> 04:10.870
Congratulations.

04:11.020 --> 04:15.320
That is something truly what a senior developer does.

04:15.460 --> 04:21.150
Figuring out the flow the architecture of a system and seeing how we can improve it.

04:21.460 --> 04:28.390
If you're able to do this then people can trust you to grow their application to manage scale and to

04:28.390 --> 04:30.130
handle project growth.

04:31.380 --> 04:32.540
But here's the thing.

04:32.610 --> 04:36.870
There's one last piece that we need to add to complete our knowledge.

04:36.870 --> 04:44.040
We've learned all the basics all the steps that we need to become senior developers and the modern technologies

04:44.040 --> 04:45.770
that senior developers to use.

04:46.020 --> 04:53.340
But to make this process go to create this entire system to make sure that we're able to send this to

04:53.340 --> 04:55.030
production live.

04:55.050 --> 05:02.010
We need something called continuous integration continuous delivery and continuous deployment.

05:02.040 --> 05:07.050
Something we're going to learn about in the next section to finally connect everything and complete

05:07.530 --> 05:12.880
our entire picture of a senior developer in the modern age.

05:12.960 --> 05:13.950
I'll see in the next section.
