WEBVTT

00:00:01.180 --> 00:00:02.190
Odprowadź ich z powrotem.

00:00:02.310 --> 00:00:07.020
Nauczmy się kilku typów, których możemy używać z maszynopisami.

00:00:07.020 --> 00:00:10.710
Pierwszy to coś, co nazywa się uczniem.

00:00:11.490 --> 00:00:14.090
A przy okazji, skąd biorą się te typy.

00:00:14.220 --> 00:00:21.060
No cóż, niektóre języki programowania mają takie typy, o których będziemy mówić, a JavaScript po prostu

00:00:21.060 --> 00:00:27.630
ich nie ma, nie oznacza, że to zła rzecz, ale maszynopis pozwala nam na ich użycie,

00:00:27.630 --> 00:00:30.060
co jest całkiem fajną funkcją.

00:00:31.390 --> 00:00:34.470
A więc krotka.

00:00:34.810 --> 00:00:47.540
Cóż, myślę, że pokazanie ci może mieć sens, co to jest krotka, powiedzmy, niech Foskett będzie

00:00:52.930 --> 00:01:05.630
sznurkiem i numerem, a teraz kosz będzie miał koszykówkę i pięć w swojej macierzy.

00:01:05.920 --> 00:01:09.730
Więc jeśli to uratuję, wszystko nadal działa.

00:01:09.730 --> 00:01:19.090
I to jest krotka krotka, którą możesz zdefiniować w tej składni i mieć w niej różne typy,

00:01:19.480 --> 00:01:30.470
więc jeśli z jakiegoś powodu zmieni się moje zamówienie i zrobię 5, a teraz Baskett pozwoli mi upewnić się, że dodaję ciąg.

00:01:30.570 --> 00:01:39.790
Dostaję błąd, ponieważ oczekuje tego konkretnego typu i tego typu zamówienia i może być bardzo

00:01:39.790 --> 00:01:44.730
przydatny dla pewnych rzeczy, których często nie używasz.

00:01:44.740 --> 00:01:53.350
Ale po prostu, jak już powiedziałem, po prostu SYNNEX swoją funkcję można użyć innej, która jest

00:01:53.350 --> 00:02:01.880
bardzo popularna, zwłaszcza, że istnieje w wielu językach programowania jest czymś o nazwie urzeka niezliczona.

00:02:01.890 --> 00:02:10.160
I tutaj możemy zrobić coś takiego, możemy powiedzieć w rozmiarze Gnome, że dostaniemy to podświetlanie.

00:02:10.330 --> 00:02:18.580
Więc może to być wszystko, czego chcemy, a my zwykle

00:02:18.580 --> 00:02:28.610
go kapitalizujemy i powiemy z nawiasami klamrowymi, że małe jest równe dwóm środkom.

00:02:28.620 --> 00:02:36.490
Teraz powiedzmy, że duże równe jest 3.

00:02:36.570 --> 00:02:52.960
A teraz, używając tego nowego typu, mogę powiedzieć, żeby rozmiar rozmiaru nazwy Lassez był łańcuchem i powiedz równy rozmiar, co to znaczy oszczędzajmy i

00:02:57.750 --> 00:03:00.810
zobaczmy, co się stanie.

00:03:00.930 --> 00:03:02.700
Nie mam lat.

00:03:02.910 --> 00:03:05.010
Wygląda na to, że działa.

00:03:05.040 --> 00:03:08.500
Nie dostaję błędów, ale jeśli pójdę do maszynopisu Dodda J. S.

00:03:11.260 --> 00:03:14.740
Whoa Dostaję tutaj jakieś fajne wyjścia.

00:03:15.070 --> 00:03:20.270
Ale wygląda na to, że też dostaję rozmiar.

00:03:20.280 --> 00:03:22.280
Należy umieścić medium.

00:03:22.720 --> 00:03:23.900
Sprawdźmy tę teorię.

00:03:23.920 --> 00:03:30.970
Mam zamiar powiedzieć, że rozmiar logu programu Konsole go.

00:03:31.060 --> 00:03:32.330
Chcesz zapisać.

00:03:32.690 --> 00:03:37.930
Zamierzam teraz zamknąć kompilator i uruchomić skrypt maszynowy.

00:03:38.010 --> 00:03:39.570
Dodgy Tak.

00:03:39.620 --> 00:03:42.310
I dostaję medium.

00:03:42.370 --> 00:03:48.460
Wiem, że to może trochę zagmatwać, ale znowu coś, co możesz przeczytać z

00:03:48.460 --> 00:03:55.410
liczbami, możesz mieć inną strukturę danych, której możesz użyć do uporządkowania informacji o swoim programie.

00:03:55.420 --> 00:04:03.850
Na przykład, gdybyśmy mieli koszyk na zakupy i mieliśmy małe średnie i duże rozmiary, a każda wartość małego i

00:04:03.850 --> 00:04:07.080
dużego medium wynosiła 1 2 i 3.

00:04:07.090 --> 00:04:15.250
Możemy użyć nazwy rozmiaru, aby upewnić się, że otrzymujemy prawidłową wartość.

00:04:17.020 --> 00:04:25.200
Teraz powiedzmy, że chcemy mieć zamiast rozmiaru 2, powiedzmy, że będziemy mieć

00:04:28.250 --> 00:04:32.530
rozmiar mały 5 na kompilatorze.

00:04:35.040 --> 00:04:40.620
Typ size small nie jest przypisywany do typu string, ale jeśli zmienię

00:04:43.170 --> 00:04:52.930
tylko na numer, wszystko działa, ponieważ rozmiar small jest teraz równy 1 i możesz zobaczyć, czy najeżdżam na to, to

00:04:52.930 --> 00:04:57.220
pokazuje mi, że rozmiar small jest równy 1.

00:04:57.220 --> 00:05:00.160
Teraz, kiedy to byłoby naprawdę przydatne.

00:05:00.430 --> 00:05:09.560
Cóż w liczbach pozwala nam zdefiniować zestaw nazwanych Constanów, tak jak mamy tutaj i używając ich, możemy ułatwić

00:05:09.560 --> 00:05:17.540
sobie dokumentowanie intencji lub stworzyć zestaw różnych klas, takich jak rozmiary, a może być może chcemy

00:05:17.900 --> 00:05:25.050
mieć wskazówki jak na przykład w lewo i każdy kierunek ma przypisaną wartość.

00:05:26.390 --> 00:05:33.570
Znowu możesz przeczytać więcej na ten temat na ich dokumentacji jest kolejnym przydatnym narzędziem.

00:05:33.570 --> 00:05:37.350
W porządku, zróbmy sobie przerwę, a zobaczę w następnej.