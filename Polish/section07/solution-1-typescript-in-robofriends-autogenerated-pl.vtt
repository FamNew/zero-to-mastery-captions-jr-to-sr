WEBVTT

00:00:00.480 --> 00:00:07.020
Witajcie ponownie, jak bardzo udało się napisać kilka rodzajów.

00:00:08.880 --> 00:00:13.950
Pokażę ci, co bym zrobił, gdybym przejrzał te pliki.

00:00:13.950 --> 00:00:16.580
Pamiętaj, że nie jest to jedyny sposób.

00:00:16.590 --> 00:00:22.320
Istnieje wiele rozwiązań tego problemu, ale miejmy nadzieję, że nauczysz się co nieco, obserwując,

00:00:22.320 --> 00:00:25.210
jak dodam typy do tych plików.

00:00:25.260 --> 00:00:31.950
Teraz pierwszą rzeczą, którą naprawdę chciałem ci pokazać, jest coś, co domyślnie pojawiło się w

00:00:31.950 --> 00:00:36.080
pliku skryptu aplikacji Kreatora ponownego indeksowania w indeksie TSX.

00:00:36.150 --> 00:00:45.750
Widzimy, że mamy w dokumencie funkcji re-act render, aby uzyskać alimenty przez id root jako element shemale.

00:00:45.860 --> 00:00:49.710
I pamiętaj, że jest to składnia typu asercji.

00:00:49.710 --> 00:00:55.530
Mówimy więc, że ufajcie nam, nie próbujcie żadnych wniosków ani niczego w tym stylu.

00:00:55.530 --> 00:00:58.030
To jest element HMO.

00:00:58.050 --> 00:01:05.450
I jak widzisz tutaj, jeśli najeżdżam na niego, to jest to element shemale, że ściana jest

00:01:05.580 --> 00:01:10.440
narodowym momentem, a my wychodzimy z pudełka z "Zdecydowanie wpisanego".

00:01:10.530 --> 00:01:13.740
Widać, że interfejs jest elementem shemale.

00:01:13.950 --> 00:01:18.650
Chciałem ci tylko pokazać, że niektórzy z was wędrują.

00:01:18.830 --> 00:01:22.170
W porządku, zacznijmy pisać maszynopis.

00:01:22.230 --> 00:01:27.690
Zacznę od list kart, ponieważ będzie to prosta i łatwa.

00:01:27.770 --> 00:01:34.420
Pamiętaj, że napisałem już dla Ciebie kilka rzeczy tutaj na górze aplikacji dot TSX.

00:01:34.460 --> 00:01:42.720
Teraz tutaj pierwsza rzecz, którą zamierzam zrobić, chodźmy do Carlist tutaj widzę, że dostaję roboty i

00:01:42.720 --> 00:01:51.030
w aplikacji lub TSX mam tego robota interfejsu, który już stworzyłem i już wyeksportowałem Mogę to

00:01:51.450 --> 00:01:55.790
zaimportować i użyć tego jako mojego typu.

00:01:55.800 --> 00:01:57.280
Więc wróćmy tutaj.

00:01:57.510 --> 00:02:14.100
Zamierzam powiedzieć, importować robota interfejsu z naszego pliku kontenera lub folderu kontenera i zróbmy hop.

00:02:14.330 --> 00:02:21.400
A teraz tutaj mogę po prostu powiedzieć, że roboty powinny być.

00:02:21.620 --> 00:02:24.980
Ta składnia jest trochę inna, ponieważ tutaj niszczymy.

00:02:25.040 --> 00:02:35.830
Więc będziemy mieli obiekt, który ma robota tablicy.

00:02:37.600 --> 00:02:40.970
Robot lub robot.

00:02:41.100 --> 00:02:43.630
Tylko dwukrotnie sprawdź, czy to ja Robot.

00:02:44.390 --> 00:02:51.290
Więc znowu zamierzam uczynić to trochę mniejszym, więc widzicie, że mówię, że te roboty

00:02:51.290 --> 00:02:54.560
będą miały typ tablicy z interfejsem.

00:02:54.560 --> 00:03:01.650
I każdy z nich będzie obiektem robota interfejsu do zapisania.

00:03:01.830 --> 00:03:03.170
I dostaję trochę błędu.

00:03:03.180 --> 00:03:06.810
To dobrze, aby uzyskać twoje, ponieważ możemy upewnić się, że wszystko działa.

00:03:06.810 --> 00:03:15.030
Widzę, że kontener nie istnieje, ponieważ muszę przejść do folderu.

00:03:15.080 --> 00:03:15.610
W porządku.

00:03:15.710 --> 00:03:16.670
Cóż, to działa.

00:03:16.670 --> 00:03:17.030
W porządku.

00:03:17.030 --> 00:03:17.990
Dodaliśmy kilka typów.

00:03:17.990 --> 00:03:19.430
To wspaniale.

00:03:19.430 --> 00:03:22.380
Teraz przejdźmy do kolejnej karty Follistim.

00:03:23.380 --> 00:03:25.980
Plik karty jest interesujący.

00:03:25.980 --> 00:03:31.820
Mam zamiar wprowadzić tu coś nowego, zwanego nierdzewnym komponentem funkcjonalnym.

00:03:31.880 --> 00:03:36.110
Stwórzmy tutaj interfejs o identyfikatorze adresu e-mail.

00:03:36.110 --> 00:03:42.590
Wiem, że moglibyśmy skorzystać z interfejsu robota, ale spróbujmy czegoś nowego.

00:03:42.590 --> 00:03:54.520
Mam zamiar powiedzieć interfejs i mam zamiar powiedzieć, że Card pozostał mniej Propp lub prop i ten interfejs będzie

00:03:54.850 --> 00:04:05.590
miał nazwę, która jest ciągiem e-mail, który jest również ciągiem znaków, a następnie identyfikator, który jest numerem

00:04:08.900 --> 00:04:19.010
i teraz tutaj jestem można powiedzieć, że ta karta koncertowa będzie ponownie działać bezstanowy składnik funkcjonalny.

00:04:19.010 --> 00:04:21.470
Czy widzisz już, jak mam autouzupełnianie?

00:04:21.560 --> 00:04:26.100
Ponownie po wyjęciu z pudełka mamy wskazówki, dlaczego możemy dodać.

00:04:26.420 --> 00:04:33.050
A jeśli przejdziesz tutaj, by zareagować, mamy masę atrybutów, które możemy wprowadzić w taki bezpaństwowy składnik

00:04:33.050 --> 00:04:33.920
funkcjonalny.

00:04:34.130 --> 00:04:38.650
A jeśli zastanawiasz się, czy to wydaje się przypadkowe, skąd je bierzesz?

00:04:38.750 --> 00:04:46.490
Pamiętaj, że mamy nasz folder modułu węzła iw typach, w których reagujemy

00:04:46.490 --> 00:04:54.860
na indeks Dot T będzie miał typ widoku SFA, zobaczmy, zobaczmy, gdzie się pojawi.

00:04:54.860 --> 00:04:56.210
Niektóre są tutaj.

00:05:00.080 --> 00:05:09.030
Tam jest misyar typu siedzenia Assefa, ale nasz edytor daje nam wystarczającą wskazówkę, aby wiedzieć, że mamy reagować

00:05:09.450 --> 00:05:10.170
jako.

00:05:10.500 --> 00:05:21.050
I ten najstarszy element funkcjonalny, który daje ci jeszcze jedną wskazówkę Będziemy mieli typ bezpaństwowca

00:05:21.380 --> 00:05:22.450
karty.

00:05:22.950 --> 00:05:25.590
Pozwól mi oszczędzić.

00:05:25.630 --> 00:05:26.410
W porządku.

00:05:26.410 --> 00:05:27.850
I to działa.

00:05:27.850 --> 00:05:32.930
Jeśli zmienię to na ciąg, który się nie powiedzie.

00:05:32.930 --> 00:05:33.430
Idealny.

00:05:33.560 --> 00:05:35.110
Więc wszystko działa.

00:05:36.080 --> 00:05:36.410
W porządku.

00:05:36.440 --> 00:05:38.480
Przejdźmy do innego komponentu.

00:05:38.480 --> 00:05:42.350
Pozwól mi to zamknąć i zróbmy komponent przewijania.

00:05:43.230 --> 00:05:47.060
W skórze komponentu widzimy, że właśnie odbieramy rekwizyty.

00:05:47.060 --> 00:05:54.320
Nie robimy żadnego destrukturyzowania, więc możemy zrobić coś ciekawego, możemy powiedzieć, że rekwizyty typu i pamiętajmy, że

00:05:55.510 --> 00:06:01.580
są trochę podobne do interfejsu kilku drobnych rzeczy, których nie możemy z nimi

00:06:01.580 --> 00:06:02.150
zrobić.

00:06:02.360 --> 00:06:09.680
I tutaj powiem, że dzieci, bo pamiętajmy, że mamy tu dzieci rekwizytów.

00:06:09.680 --> 00:06:14.590
Dzieci będą równe GSX.

00:06:14.700 --> 00:06:18.450
I znów mamy pomysły tego, co chcemy.

00:06:18.450 --> 00:06:21.220
Chcemy elementu GSX.

00:06:21.600 --> 00:06:31.910
Chcemy, aby dzieci miały typ elementu GSX GSX jest składnią, której używamy z szacunkiem.

00:06:31.920 --> 00:06:36.410
A jeśli przejdziemy do aplikacji dot TSX, zobaczymy to w zwoju.

00:06:36.410 --> 00:06:39.760
Dziecko jest elementem GSX.

00:06:40.110 --> 00:06:49.580
Więc jeśli powiem, że wciąż musimy dodać ten typ z typem, muszę tu zrobić to samo.

00:06:50.800 --> 00:06:59.020
A potem dla rekwizytów mogę po prostu powiedzieć "props" i upewniamy się, że zawsze renderujemy

00:06:59.920 --> 00:07:03.220
element GSX wewnątrz komponentu przewijania.

00:07:03.220 --> 00:07:08.810
A tak przy okazji, być może mamy czasy, w których nie mamy dzieci.

00:07:08.950 --> 00:07:14.820
Być może moglibyśmy chcieć użyć tego komponentu jako czegoś, co nie zawsze oddaje dzieci.

00:07:15.010 --> 00:07:17.190
W takim przypadku dodajmy tutaj znak zapytania.

00:07:17.290 --> 00:07:21.810
Więc może lub nie może pracować z rekwizytami lub dziećmi.

00:07:22.060 --> 00:07:23.270
Ładny.

00:07:23.470 --> 00:07:27.420
Kontynuujmy i wykonujmy pole wyszukiwania.

00:07:27.470 --> 00:07:34.070
Teraz mamy kilka interesujących rzeczy, które dzieją się w polu wyszukiwania, głównie w przypadku zmiany zdarzenia zmiany

00:07:34.070 --> 00:07:34.570
wyszukiwania.

00:07:34.790 --> 00:07:46.790
Zróbmy więc coś tutaj powiedzmy, że interfejs będzie nazywany rekwizytami pola wyszukiwania interfejsu.

00:07:46.830 --> 00:07:53.450
I wiem, że zmieniam konwencję nazewnictwa, ale chcę pokazać wiele sposobów na zrobienie tego.

00:07:55.080 --> 00:07:57.660
A tutaj rekwizyty.

00:07:57.720 --> 00:08:00.650
Cóż, to zmiana w zakresie wyszukiwania Propp.

00:08:01.080 --> 00:08:11.170
Tak więc zmiana wyszukiwania jest tym, co zmienia się w wyszukiwaniu, jeśli pamiętamy, że zmiana jest czymś, co powoduje

00:08:11.170 --> 00:08:11.850
wydarzenie.

00:08:12.010 --> 00:08:21.550
A jeśli przejdziemy do aplikacji dot TSX, zauważymy, że zmiana wyszukiwania jest po prostu zdarzeniem, które niczego nie

00:08:21.550 --> 00:08:24.000
zwraca, tylko aktualizuje stan.

00:08:24.020 --> 00:08:25.150
Jak możemy to zrobić?

00:08:25.160 --> 00:08:27.270
I ten jest trochę trudny.

00:08:27.270 --> 00:08:34.540
Powiem, że to zajmie to wydarzenie.

00:08:34.710 --> 00:08:37.580
Cóż to będzie za wydarzenie.

00:08:38.490 --> 00:08:46.110
Jeśli pamiętasz, że jest to wydarzenie On Change, ale reagujesz pod maską, ma swoją własną wersję

00:08:46.110 --> 00:08:48.260
implementacji HMO po zmianie.

00:08:48.270 --> 00:08:56.220
Ponownie, jeśli przejdziesz do typów maszyn i zareagujesz, zobaczysz, że mają coś, co nazywa się syntetycznymi

00:08:56.310 --> 00:08:56.940
wydarzeniami.

00:08:57.990 --> 00:09:04.470
I znowu nie martw się, jeśli nie wiesz o tym, jeśli przeszukałeś coś, co miałeś do czynienia z wydarzeniami, aby

00:09:04.470 --> 00:09:11.670
zareagować, to faktycznie powiesz, co powinieneś robić w przypadku wydarzeń, więc to nie znaczy, że nie wiesz, jak to zrobić to tylko

00:09:11.670 --> 00:09:18.060
jedna z tych rzeczy, których się nauczysz, po prostu trzeba się jej nauczyć, a potem stanie się standardem.

00:09:18.110 --> 00:09:23.200
Powiedzmy, że to będzie powtórne wydarzenie syntetyczne.

00:09:23.270 --> 00:09:30.700
Widzisz, że mam to ukończenie i to syntetyczne wydarzenie będzie elementem HMO, ponieważ

00:09:34.020 --> 00:09:42.720
mamy element wejściowy, więc jest to zdarzenie, które pochodzi z elementu wejściowego. Myślę, że jest to

00:09:42.720 --> 00:09:43.920
trochę trudne.

00:09:44.950 --> 00:09:49.440
A potem w końcu Więc to jest parametr, który wróci.

00:09:49.510 --> 00:09:50.950
Tak więc zwrócę cokolwiek.

00:09:51.190 --> 00:09:51.880
Więc zamierzam

00:09:55.040 --> 00:10:00.370
ocalić i jest zadeklarowany, ale jego wartością nigdy nie jest czytanie moich rekwizytów w polu wyszukiwania.

00:10:00.380 --> 00:10:10.040
Dodajmy teraz, że teraz powiem, że ta zmiana w wyszukiwaniu będzie właściwa z prawej strony.

00:10:10.060 --> 00:10:11.080
Wszystko przemija.

00:10:11.230 --> 00:10:12.000
Bardzo fajny.

00:10:13.890 --> 00:10:14.250
W porządku.

00:10:14.250 --> 00:10:15.990
Zrobiliśmy nasze komponenty.

00:10:16.020 --> 00:10:19.680
Przejdźmy do aplikacji dot TSX.

00:10:19.680 --> 00:10:25.980
Jak tu zobaczyłeś, zrobiłem już dla ciebie kilka rzeczy i mamy składnik Riak,

00:10:26.070 --> 00:10:28.870
który przyjmuje rekwizyty i stan.

00:10:28.950 --> 00:10:30.900
I to znowu jest dość standardowe.

00:10:30.900 --> 00:10:37.980
Możesz zobaczyć tutaj na dole, który mówi składnik klasy Riak i otrzymuje rekwizyty i stan.

00:10:37.980 --> 00:10:41.000
Zobaczysz to bardzo podczas pracy z reakcją.

00:10:41.220 --> 00:10:47.100
I już zdefiniowaliśmy stan i puste rekwizyty.

00:10:47.190 --> 00:10:55.800
Teraz następną rzeczą, którą chcemy zrobić, to być może w funkcji konstruktora nadać jej również podpory

00:10:55.980 --> 00:11:03.080
z wysokim czapem, czyli interfejs rekwizytów i przewińmy w dół do zmiany wyszukiwania.

00:11:03.180 --> 00:11:04.400
Tym razem już to zrobiliśmy.

00:11:04.440 --> 00:11:15.690
Wiemy, że będzie to powtórne wydarzenie syntetyczne, które będzie elementem wejściowym HMO.

00:11:15.890 --> 00:11:18.680
I pamiętajcie, że ta funkcja powróci.

00:11:18.680 --> 00:11:26.750
Pozwól, że po prostu sprawię, że to trochę większe, po prostu wróci do pustki.

00:11:26.890 --> 00:11:28.900
Uratujmy.

00:11:29.080 --> 00:11:30.390
Wszystko działa.

00:11:33.330 --> 00:11:39.000
Moglibyśmy również powiedzieć o zapotrzebowaniu na komponenty, że nie zwracają niczego, więc możemy po prostu

00:11:39.000 --> 00:11:40.140
tu anulować.

00:11:40.170 --> 00:11:49.490
To samo z renderowaniem lub renderowaniem, jeśli użyjemy voyde, nie będzie działać, ponieważ zwraca element, więc możemy

00:11:49.500 --> 00:11:58.600
po prostu powiedzieć "re-act dot element" lub w naszym przypadku moglibyśmy powiedzieć "GSX perfect" i zaczynacie

00:12:06.690 --> 00:12:14.760
wpadać na pomysł za tym jest więcej typów, które możemy dodać, ale mamy nadzieję, że

00:12:14.760 --> 00:12:19.860
czujesz się komfortowo, dodając typy do komponentu Riak.

00:12:21.310 --> 00:12:25.830
Widzisz teraz część posiadania deklaracji typu.

00:12:25.890 --> 00:12:31.640
Pamiętaj, że jeśli pójdziemy pakować Jason'a, mamy typy typu.

00:12:31.910 --> 00:12:42.210
Nie ma mowy, abyśmy mogli powiedzieć, że reagujemy na syntetyczne zdarzenie Dauta lub GSX lub SFE dla elementów

00:12:42.220 --> 00:12:43.360
funkcjonalnych.

00:12:43.360 --> 00:12:52.390
To wszystko pochodzi od ponownego przetwarzania typów przez ponowne ich ponowne użycie, kiedy tylko używamy biblioteki stron trzecich, możemy chcieć sprawdzić,

00:12:52.390 --> 00:12:58.930
czy możemy uzyskać deklaracje typu z witryny o zdecydowanie określonym typie, tak jak pokazałem wam

00:12:59.860 --> 00:13:00.750
ponad wszystko.

00:13:00.770 --> 00:13:07.760
Gdy odejdzie się od niezręczności składni, jeśli po raz pierwszy ją zobaczysz, na pewno

00:13:07.760 --> 00:13:12.770
istnieją naprawdę fajne rzeczy, które nam się przytrafiają na przykład.

00:13:12.770 --> 00:13:22.550
Teraz, jeśli z jakiegoś powodu nigdy nie wyślę parametru ID lub powiedzmy, że w tym komponencie karty

00:13:22.550 --> 00:13:32.460
nigdy nie przekazuję identyfikatora, jeśli zapiszę tę wysokość natychmiast otrzymam błąd, zanim jeszcze 8 będę mógł zobaczyć aplikację.

00:13:32.510 --> 00:13:37.080
Mam na myśli to, że dostaliśmy to, ponieważ otrzymaliśmy ten błąd z reakcji na reakcję.

00:13:37.250 --> 00:13:42.910
Ale nawet nie uruchamia naszej aplikacji, bo już wiemy, że

00:13:42.920 --> 00:13:50.550
nie będzie działać tak, jak zamierzaliśmy, ponieważ powiedzieliście mi, że potrzebujemy własności ID w samochodzie.

00:13:50.570 --> 00:13:52.460
W porządku, to tyle na teraz.

00:13:52.460 --> 00:13:54.490
Mam nadzieję, że bawiłeś się tym wyzwaniem.

00:13:54.800 --> 00:13:57.280
I jak zawsze zobaczę cię w następnym wideo.