WEBVTT

00:00:00.890 --> 00:00:07.260
Arahkan mereka kembali dan bawa diskusi kita kembali ke sesuatu

00:00:07.320 --> 00:00:18.050
yang sebelumnya telah kita bicarakan dengan Dr. Ide arsitektur layanan mikro gagasan bahwa sebelum kita memiliki infrastruktur raksasa

00:00:18.080 --> 00:00:25.760
monolitik atau basis kode yang melakukan segalanya untuk kita semua bagian besar semua bagian kecil bersama-sama di

00:00:25.760 --> 00:00:29.390
satu tempat menjalankan aplikasi dan logika kita.

00:00:29.580 --> 00:00:38.700
Sekarang dengan buruh pelabuhan dan AWOS sekarang membuat segalanya sangat mudah bagi kami untuk mengelola mesin-mesin ini dan

00:00:38.700 --> 00:00:43.600
menghubungkan mereka gagasan layanan Micro telah menjadi semakin populer.

00:00:43.630 --> 00:00:50.050
Itu adalah ide untuk membagi aplikasi Anda menjadi satu set layanan yang lebih kecil saling berhubungan.

00:00:50.050 --> 00:00:57.430
Alih-alih membangun aplikasi monolitik tunggal dan setiap layanan Micro adalah aplikasi kecil yang memiliki

00:00:57.820 --> 00:01:05.530
arsitektur sendiri yang terdiri dari logika bisnisnya sendiri dan berkaitan dengan melakukan satu hal dengan

00:01:05.530 --> 00:01:06.670
sangat baik.

00:01:06.670 --> 00:01:12.790
Sekarang melihat ini Anda berpikir ini tampaknya monolitik sepertinya pilihan yang jauh lebih baik daripada hal-hal

00:01:12.790 --> 00:01:17.190
membingungkan yang terjadi di sini dan Anda mungkin benar lagi.

00:01:17.200 --> 00:01:21.670
Ini benar-benar tergantung pada apa yang dilakukan perusahaan Anda.

00:01:22.530 --> 00:01:30.570
Namun satu keuntungan besar dengan layanan Micro adalah bahwa sekarang Anda memiliki bongkahan kecil yang dapat

00:01:30.660 --> 00:01:38.630
diuji sendiri sehingga kami dapat memiliki tim pengembang yang berbeda dan semuanya dapat dirilis secara terpisah

00:01:38.660 --> 00:01:41.550
untuk diproduksi satu per satu.

00:01:41.570 --> 00:01:44.340
Kami tidak harus memastikan bahwa semua bagian bekerja bersama.

00:01:44.360 --> 00:01:51.980
Maksud saya kita masih melakukan tetapi di sini kita harus memastikan bahwa semua tim pengembang bekerja pada satu basis kode.

00:01:52.070 --> 00:01:59.150
Tidak ada yang mematahkan apa pun dan semua tes lulus sebelum kami mengirimnya ke produksi versus di sini di

00:01:59.150 --> 00:02:06.830
mana kami dapat memiliki tim individu kecil yang hanya khawatir tentang satu layanan satu mesin mereka dan memastikan bahwa itu benar-benar

00:02:06.830 --> 00:02:13.000
bagus dan Anda dapat memiliki satu produksi yang diperbarui sementara yang lain mungkin diperbarui dalam produksi dua

00:02:13.010 --> 00:02:14.390
minggu dari sekarang.

00:02:14.510 --> 00:02:21.560
Dan selama mereka memiliki apa yang kita sebut perjanjian tingkat layanan atau SLA selama mereka mengatakan hei, pastikan tidak peduli apa

00:02:21.560 --> 00:02:27.140
pun pembaruan yang Anda lakukan, Anda memberi saya data pengembalian ini atau Anda merespons saya dengan cara

00:02:27.140 --> 00:02:27.740
ini.

00:02:27.740 --> 00:02:34.460
Kemudian Anda dapat bekerja secara individual pada kotak-kotak ini dan itu membuat perusahaan-perusahaan besar yang memiliki

00:02:34.460 --> 00:02:38.280
banyak tim Daval ini bekerja jauh lebih efisien.

00:02:38.510 --> 00:02:43.910
Dan ini adalah arsitektur yang sangat menarik yang Anda benar-benar ingin pikirkan dan awasi

00:02:44.060 --> 00:02:47.840
karena itu akan menjadi semakin populer seiring berjalannya waktu.

00:02:48.970 --> 00:02:54.820
Baiklah mari kita kembali ke Amazon Web Services dan berbicara tentang fungsi lambda di video berikutnya.