WEBVTT

00:00:02.020 --> 00:00:07.560
Witamy z powrotem istnieje mnóstwo języków programowania tam.

00:00:07.590 --> 00:00:08.970
Słyszeliśmy o nich dobrze.

00:00:09.180 --> 00:00:10.080
Pyton.

00:00:10.140 --> 00:00:13.190
Ruby Java C ++.

00:00:13.350 --> 00:00:21.500
Jest tona i chociaż javascript jest dominującym językiem w sieci i wraz z wprowadzeniem takich rzeczy

00:00:21.500 --> 00:00:28.730
jak węzeł Tak, możemy teraz używać javascript poza siecią, być może również na serwerze

00:00:28.730 --> 00:00:29.840
zaplecza.

00:00:29.840 --> 00:00:37.510
Świat wciąż ma wiele różnych języków, które są dostosowane do ich własnej domeny i możliwości.

00:00:37.660 --> 00:00:44.380
A gdybyśmy musieli jakoś sklasyfikować wszystkie te języki programowania, prawdopodobnie zrobilibyśmy coś

00:00:44.380 --> 00:00:44.970
takiego.

00:00:48.470 --> 00:00:54.500
W tym filmie będziemy mówić o głównym spektrum dynamiki i statyczności tego, jak języki programowania

00:00:54.500 --> 00:00:56.080
mogą się różnić.

00:00:57.160 --> 00:01:06.600
Dynamicznie wpisane i statycznie wpisane widzimy tutaj, że javascript jest dynamicznie typem do języka,

00:01:07.610 --> 00:01:15.830
podobnie jak inne popularne języki programowania, takie jak zamykanie PH Ruby Python.

00:01:16.000 --> 00:01:26.480
Z drugiej strony języki takie jak Java Haskell skalarne C ++ są statycznymi lub statycznie napisanymi językami.

00:01:26.580 --> 00:01:28.550
Ale co to znaczy.

00:01:30.650 --> 00:01:33.140
Cóż, pozwól mi po prostu to zademonstrować.

00:01:35.060 --> 00:01:40.250
Jeśli otworzę konsolę tutaj i Oh, to miłe tło dzisiaj.

00:01:40.280 --> 00:01:46.430
W każdym razie wracamy do konsoli, abyśmy mogli wpisać javascript w javascript, ponieważ jest on wpisywany dynamicznie.

00:01:46.430 --> 00:01:48.140
Możemy zrobić coś takiego.

00:01:48.140 --> 00:01:54.650
Zmienna A równa się 100.

00:01:54.710 --> 00:01:55.300
W porządku.

00:01:55.410 --> 00:01:57.270
To całkiem spodziewane.

00:01:57.270 --> 00:02:00.080
Wiemy, jak działa javascript i to jest w porządku.

00:02:00.960 --> 00:02:04.600
Ale w niektórych językach to by nie działało.

00:02:04.680 --> 00:02:14.340
Widzisz dynamicznie napisany język, który pozwala nam nie musieć określać, jaką zmienną będzie

00:02:14.440 --> 00:02:16.030
ta zmienna.

00:02:16.230 --> 00:02:17.160
Co to znaczy.

00:02:17.340 --> 00:02:19.490
No cóż, w statycznie napisanym języku.

00:02:19.530 --> 00:02:24.350
Powiedzmy, że pisaliśmy C ++, który jest statycznie napisanym językiem.

00:02:24.560 --> 00:02:26.760
Musielibyśmy zrobić coś takiego.

00:02:26.990 --> 00:02:33.980
I nie będę podświetlany, ponieważ ta przeglądarka nie rozpozna C ++, ale gdybym miał zrobić

00:02:33.980 --> 00:02:36.710
to samo, musiałbym powiedzieć int.

00:02:36.770 --> 00:02:42.670
I oznacza liczbę całkowitą, a następnie nową.

00:02:43.010 --> 00:02:54.420
Powiem, że pozwolisz mi dodać średnik tutaj i na nowej linii, którą powiedziałbym, że A równa się 100, którą

00:02:54.420 --> 00:03:01.490
widzisz statycznie napisanym językiem, muszę powiedzieć, jaki rodzaj tej zmiennej będzie.

00:03:01.560 --> 00:03:03.930
W tym przypadku jest to liczba całkowita.

00:03:03.930 --> 00:03:10.770
Gdyby to był ciąg jak halo, musiałbym napisać ciąg i tak dalej i tak dalej.

00:03:10.770 --> 00:03:18.260
W przypadku statycznie pisanego języka musimy wyraźnie zadeklarować zmienne przed ich użyciem.

00:03:19.240 --> 00:03:23.850
Dynamicznie napisane języki nie są związane z tym ograniczeniem.

00:03:24.640 --> 00:03:27.160
Nie są związani z konkretnym typem.

00:03:27.160 --> 00:03:32.690
JavaScript jest wystarczająco inteligentny i powie: tak, tak, tak, zmienna.

00:03:32.710 --> 00:03:33.500
To 100.

00:03:33.520 --> 00:03:33.830
O tak.

00:03:33.880 --> 00:03:34.880
To jest liczba całkowita.

00:03:34.990 --> 00:03:36.560
Jest to typ całkowity.

00:03:36.820 --> 00:03:38.230
Wow, jestem taki mądry.

00:03:38.230 --> 00:03:39.640
Tak właśnie jest javascript.

00:03:40.880 --> 00:03:46.390
W dynamicznie wpisywanych językach sprawdzanie typów odbywa się w czasie wykonywania.

00:03:46.460 --> 00:03:47.380
Co to znaczy.

00:03:47.600 --> 00:03:55.490
Cóż, jeśli pamiętasz w naszej dyskusji na temat wydajności przeglądarki javascript uruchamia się w

00:03:56.750 --> 00:04:05.110
przeglądarce w środowisku wykonawczym lub w kompilacji odrzutowej lub w czasie, podczas gdy użytkownik faktycznie przegląda

00:04:05.110 --> 00:04:05.790
witrynę.

00:04:05.820 --> 00:04:09.720
JavaScript działa i jest kompilowany w tle.

00:04:09.870 --> 00:04:15.660
Jeśli pamiętasz naszą kartę wydajności, mamy dane dotyczące wydajności skryptów, które

00:04:15.660 --> 00:04:21.950
były tym żółtym wykresem kołowym lub kawałkiem żółtego, które zawierało również kompilację javascript.

00:04:22.290 --> 00:04:29.520
Dzięki temu możemy używać dynamicznie pisanych języków, które mogą przypisywać dowolne wartości dowolną zmienną, a

00:04:29.760 --> 00:04:31.550
nie zostaniesz złapany.

00:04:31.590 --> 00:04:38.880
Podczas pracy w przeglądarce mogą pojawić się błędy podczas przeglądania strony internetowej, ale z tego

00:04:38.880 --> 00:04:42.680
powodu nie musimy się o to martwić.

00:04:42.800 --> 00:04:44.300
Wygląda całkiem nieźle.

00:04:44.300 --> 00:04:46.550
Dlaczego mielibyśmy kiedykolwiek chcieć to zrobić?

00:04:46.550 --> 00:04:53.510
Jest to o wiele prostsze i łatwiej nam napisać, co zamierzamy zobaczyć, dlaczego nie zawsze jest to

00:04:53.510 --> 00:04:56.870
idealne rozwiązanie i dlaczego może powodować problem.

00:04:58.170 --> 00:05:04.260
Ale zanim do tego dojdzie, w językach programowania trwają święte wojny, w których ludzie

00:05:04.530 --> 00:05:11.520
myślący statycznie, są na dobrej drodze i myślą, że dynamicznie typowane języki są okropne i na

00:05:11.520 --> 00:05:12.150
odwrót.

00:05:12.150 --> 00:05:18.090
Ludzie mówią, że statycznie napisane języki to strata czasu, a dynamiczne języki programowania są

00:05:18.240 --> 00:05:19.530
drogą do zrobienia.

00:05:19.770 --> 00:05:25.410
Z tego powodu podchodzę lekko do tego tematu, ponieważ ludzie są tak uparci, że mają tak silne

00:05:25.410 --> 00:05:27.120
opinie na ten temat.

00:05:27.210 --> 00:05:33.150
Ale znowu starsi programiści nie koncentrują się na tym, co jest słuszne, co jest niewłaściwe. Klyce koncentruje się na

00:05:33.150 --> 00:05:38.530
zaletach i wadach, gdy jeden jest dobry w stosunku do drugiego, abyśmy mogli podejmować mądre decyzje.

00:05:38.550 --> 00:05:41.850
Porozmawiajmy o zaletach.

00:05:41.960 --> 00:05:51.740
Najważniejszą rzeczą przy statycznie napisanym języku jest to, że dostajemy dokumentację.

00:05:52.130 --> 00:05:56.340
Być może lepszym sposobem na wykazanie tego jest faktyczne napisanie funkcji.

00:05:56.480 --> 00:06:05.200
Jeśli powiedzmy, że zamierzam to usunąć i powiedzieć, że niektóre funkcje, w tym niektóre zamierzam użyć nieco składni,

00:06:05.200 --> 00:06:08.540
która może nie być ci znana.

00:06:08.560 --> 00:06:10.270
Ale na razie wszystko jest w porządku.

00:06:10.270 --> 00:06:23.690
Po prostu założymy, że to działa, powiemy, że a jest liczbą, a B jest również liczbą i tutaj możemy po prostu

00:06:23.900 --> 00:06:27.070
zwrócić a plus b

00:06:29.790 --> 00:06:33.030
i zamknąć nasz nawias funkcyjny.

00:06:33.030 --> 00:06:37.040
To nie jest javascript, jeśli prowadzimy tę wojnę, aby uzyskać błąd.

00:06:37.380 --> 00:06:42.910
Ale to pokazuje, co potrafi statycznie napisany język.

00:06:42.990 --> 00:06:50.550
Zobaczysz, czy pojawił się nowy programista i uruchomił funkcję SUM z czymś

00:06:50.550 --> 00:06:59.110
innym niż liczba, powiedzmy, że uruchomili funkcję sumy przy odrobinie powitania i może coś.

00:06:59.130 --> 00:07:08.950
No cóż, zanim jeszcze będziemy umieszczać ten kod w przeglądarce lub w produkcji.

00:07:09.010 --> 00:07:12.050
Bo powie ci, że robisz coś złego tutaj.

00:07:12.100 --> 00:07:18.160
Spodziewam się liczby w liczbie tutaj i nie dajesz mi tego.

00:07:18.280 --> 00:07:24.170
I w tym sensie języki pisane statycznie są samokonujące.

00:07:24.190 --> 00:07:27.390
To mogę przejść do projektu i od razu to zobaczyć.

00:07:27.580 --> 00:07:33.460
Nawet jeśli nazwa została źle nazwana i była to skomplikowana funkcja, widzę, jakiego

00:07:33.520 --> 00:07:41.750
rodzaju parametrów się spodziewa i unikam popełnienia tego błędu. Drugi profesjonalista ze statycznego języka maszynowego jest tym, że z powodu

00:07:41.750 --> 00:07:49.890
tej funkcji z naszymi identyfikatorami lub edytorami tekstu, takimi jak sublime lub kod wizualny lub dowolny ulubiony edytor tekstu.

00:07:50.360 --> 00:07:53.900
Pomaga to w automatycznym uzupełnianiu w twoich edytorach.

00:07:54.050 --> 00:08:00.470
Możesz pobrać wtyczki, które mówią, że zanim jeszcze to zrobisz, powinieneś mieć numer, który jest

00:08:00.470 --> 00:08:02.690
naprawdę fajny, kiedy się rozwijasz.

00:08:02.690 --> 00:08:08.840
Wreszcie najważniejsza rzecz i tak, jest o wiele więcej profesjonalistów, ale skupiamy się tylko

00:08:08.840 --> 00:08:09.860
na głównych.

00:08:09.920 --> 00:08:15.140
Najważniejszą rzeczą w statycznie napisanych językach jest to, że dostaniesz mniej błędów.

00:08:15.140 --> 00:08:19.750
Otrzymasz mniej błędów w produkcji, ponieważ to nigdy nie doprowadzi do produkcji.

00:08:19.760 --> 00:08:28.670
Jeśli to się nie powiedzie w czasie, który nazywamy czasem kompilacji, zanim jeszcze wyślemy go do przeglądarki, ukrywamy, że wcześnie wrzuciliśmy

00:08:28.680 --> 00:08:34.100
te błędy na wczesnym etapie, więc w produkcji przez większość czasu będzie

00:08:34.100 --> 00:08:36.830
mniej błędów w statycznie napisanym języku.

00:08:36.890 --> 00:08:40.080
I nie martw się, porozmawiamy o kompilacji i jak to się będzie dalej działo.

00:08:41.370 --> 00:08:42.950
Brzmi już świetnie.

00:08:42.960 --> 00:08:44.040
Błędy w autobusie.

00:08:44.040 --> 00:08:49.120
Łatwa dokumentacja zdrowych, pełnych i kompletnych edytorów.

00:08:49.140 --> 00:08:52.150
Dlaczego więc nie zrobimy statycznie napisanego języka?

00:08:53.150 --> 00:08:55.420
Cóż, są pewne minusy.

00:08:55.490 --> 00:09:01.490
Numer jeden jest taki, że oczywiście sprawiliśmy, że nasz kod jest trochę trudniejszy do odczytania.

00:09:01.580 --> 00:09:02.420
Jest bardziej złożony.

00:09:02.420 --> 00:09:06.360
Teraz dodajemy kolejne warstwy do naszych programów.

00:09:06.620 --> 00:09:12.590
A to zajmie trochę czasu, aby dowiedzieć się, czy mamy projekt i mamy nowych ludzi dołączających do naszej firmy.

00:09:12.620 --> 00:09:18.200
Będziemy musieli nauczyć ich, jak pisać więcej kodu i jak to poprawnie napisać, to

00:09:18.200 --> 00:09:19.730
dodatkowa warstwa złożoności.

00:09:20.820 --> 00:09:24.110
I zawsze chodzi o właściwe programowanie.

00:09:24.210 --> 00:09:28.790
Dodanie dodatkowej warstwy złożoności naprawdę przyniesie korzyści projektowi.

00:09:29.720 --> 00:09:37.160
Innymi wadami lub argumentami przeciw statycznie napisanym językom jest to, dlaczego nie możesz po prostu pisać

00:09:37.250 --> 00:09:38.440
lepszych testów.

00:09:38.450 --> 00:09:46.430
Temat, który omawiamy w innej sekcji, wielu ludzi bardzo podnieca się statycznym typowaniem i zapomina

00:09:46.520 --> 00:09:50.480
o pisaniu dobrych testów dobrych testów jednostkowych.

00:09:51.120 --> 00:09:55.550
Zanim zaczniesz pisać statycznie, szczególnie w języku takim jak javascript.

00:09:55.560 --> 00:10:01.320
Upewnij się, że masz dobre testy jednostkowe i nie zapominasz o pisaniu testów jednostkowych i zakładasz, że tak, tylko

00:10:01.320 --> 00:10:06.240
dlatego, że mam statyczne pisanie, nie dostanę żadnych błędów, które po prostu nie są prawdziwe.

00:10:07.210 --> 00:10:14.230
Na koniec, ze statycznie napisanym językiem, będziesz miał wolniejszy proces rozwoju, ponieważ teraz masz

00:10:14.260 --> 00:10:20.650
dodatkowy krok, w którym podczas kodowania pojawia się kolejna kontrola, aby zobaczyć, że

00:10:20.650 --> 00:10:22.820
nie popełniasz żadnych błędów.

00:10:23.820 --> 00:10:30.480
A to tak naprawdę spowalnia proces programowania i szybkość tworzenia kodu oraz uruchamiania kodu i

00:10:30.510 --> 00:10:32.290
wysyłania go do produkcji.

00:10:33.700 --> 00:10:38.980
Widać to z dynamicznie pisanymi językami i właśnie dlatego javascript był tak

00:10:38.980 --> 00:10:46.660
popularny, że spędzasz mniej czasu na debugowaniu składni i błędów semantycznych w ten sposób, a zamiast tego większość czasu na

00:10:46.660 --> 00:10:52.980
debugowanie spoczywa wyłącznie na logice i błędach, które jako programista są o wiele bardziej interesujące .

00:10:55.330 --> 00:10:57.650
W porządku, wróćmy do tego.

00:10:57.700 --> 00:11:05.620
Istnieje kilka innych za i przeciw i każdy ma zawsze zdanie, jeśli chodzi o te dwa tematy, ale

00:11:05.920 --> 00:11:07.750
najważniejsze jest to.

00:11:07.750 --> 00:11:11.980
Typy statyczne zwykle zapobiegają błędom i pomagają zapobiegać powstawaniu błędów.

00:11:12.040 --> 00:11:20.710
Dynamiczne pisanie pozwala ci być bardziej elastycznym i pisać szybciej oprogramowanie maszynopisowe, dzięki czemu możemy uczynić

00:11:21.010 --> 00:11:26.000
javascript, aby zachowywał się jak statycznie napisany język.

00:11:26.020 --> 00:11:36.940
Dodaje typy javascript, dzięki czemu javascript jest wyjątkowo bezpieczny, ale zanim przejdę dalej, pokażę ci, jak

00:11:37.030 --> 00:11:38.890
działa skrypt.

00:11:39.070 --> 00:11:47.030
Porozmawiajmy o dwóch pozostałych częściach tego wykresu, które często mylą się z dynamicznym i statycznym typowaniem.

00:11:47.060 --> 00:11:48.570
Zobaczę w następnym.

00:11:48.710 --> 00:11:48.960
Przez.