WEBVTT

00:00:01.060 --> 00:00:08.380
Witaj ponownie. Pokażę ci typ. Teraz, gdy dobrze go nie polecam, ale wciąż tam jest, nadal ma

00:00:09.010 --> 00:00:12.430
kilka przypadków użycia, ale proszę bądź ostrożny.

00:00:12.430 --> 00:00:19.330
Mam zamiar zrobić kilka wykrzykników tutaj, ponieważ jest to coś, czego używasz, a chcesz się

00:00:19.330 --> 00:00:21.840
upewnić, że używasz go poprawnie.

00:00:22.090 --> 00:00:25.880
I to jest każdy rodzaj, kiedy robisz tu więcej miejsca.

00:00:28.420 --> 00:00:39.400
Mówimy, niech cokolwiek jest dowolnego typu i bądźmy tutaj dramatyczni.

00:00:39.670 --> 00:00:48.730
Nie, ja to robię i cokolwiek może być, co chcemy.

00:00:48.940 --> 00:00:55.210
Na przykład mogę powiedzieć, że cokolwiek równa się pięciu.

00:00:55.400 --> 00:00:59.450
I może przeliterować.

00:00:59.670 --> 00:01:00.100
W porządku.

00:01:00.120 --> 00:01:01.430
Brak błędów kompilacji.

00:01:01.470 --> 00:01:02.210
Mogę zrobić.

00:01:02.250 --> 00:01:05.420
Prawdziwe.

00:01:05.620 --> 00:01:09.690
Potrafię tworzyć listy o tym rozmiarze od góry.

00:01:09.700 --> 00:01:10.360
W porządku.

00:01:10.360 --> 00:01:11.320
To też działa.

00:01:12.400 --> 00:01:23.140
Mogę nawet zrobić, powiedzmy, cokolwiek on nazywa kosz, który jest ludźmi z góry i nie ma żadnych błędów, które

00:01:23.770 --> 00:01:30.240
widzisz, ponieważ sugerują, że nazwa może być dowolnym typem, który chcemy.

00:01:30.430 --> 00:01:33.120
I myślisz sobie, huh.

00:01:33.550 --> 00:01:41.440
Więc chodzi mi o to, że javascript nie jest typem, w którym nie używamy statycznego

00:01:41.440 --> 00:01:42.160
pisania.

00:01:42.430 --> 00:01:44.470
Dlaczego miałbyś kiedykolwiek chcieć tego użyć?

00:01:44.530 --> 00:01:49.780
I masz rację, używając tego, lekceważysz wszystkie zalety maszynopisu, bo

00:01:50.110 --> 00:01:57.520
cokolwiek byśmy nigdy nie wyrzucili, może to być cokolwiek chcemy, ale każdy jest przydatny w

00:01:57.520 --> 00:02:03.280
przypadkach, powiedzmy, gdzie pracujesz konwersję kodu do kodu javascript na kod maszynopisu.

00:02:03.520 --> 00:02:08.800
A może to zająć dużo czasu, a w międzyczasie możesz chcieć po

00:02:08.800 --> 00:02:15.920
prostu umieścić naprawdę skomplikowane funkcje lub naprawdę skomplikowane obiekty, których nie możemy od razu zdefiniować, tak jak tutaj.

00:02:16.000 --> 00:02:18.410
Ale znowu bądź bardzo ostrożny.

00:02:18.550 --> 00:02:25.000
W zasadzie korzystasz teraz z zalet maszynopisu, więc jeśli masz cały swój

00:02:25.330 --> 00:02:28.420
kod, nie używasz właściwie maszynopisu.

00:02:29.580 --> 00:02:33.650
Kolejną interesującą rzeczą, o której możemy się dowiedzieć, jest coś, co nazywa się pustką.

00:02:34.470 --> 00:02:37.280
A pustka jest dość powszechna, gdy pracujemy z funkcją.

00:02:37.560 --> 00:02:46.920
Powiedzmy, że mamy funkcję śpiewającą i ta funkcja synchronizacji niczego nie zwraca.

00:02:47.190 --> 00:02:50.740
To będzie tylko okno dialogowe konsoli.

00:02:51.540 --> 00:02:54.680
Lub po prostu być bardziej ekspresyjnym.

00:02:54.690 --> 00:02:56.520
Nie mamy tutaj oświadczenia zwrotnego.

00:02:56.520 --> 00:02:58.660
Po prostu zrobimy dialog w konsoli.

00:02:59.130 --> 00:03:01.470
La la la la la la la.

00:03:01.470 --> 00:03:02.400
Piękna piosenka.

00:03:03.230 --> 00:03:13.100
Teraz i tutaj, jeśli dodamy do niej typy, ponieważ ta funkcja nie zwraca niczego, co mówimy, nieważne nic nie

00:03:13.100 --> 00:03:14.090
zwraca.

00:03:14.270 --> 00:03:15.970
I widzisz, że to nie zawodzi.

00:03:16.100 --> 00:03:23.720
Jeśli zwrócimy coś, powiedzmy, że zwracamy Lalah, otrzymujemy błąd, ponieważ nie spodziewamy się

00:03:23.720 --> 00:03:24.470
powrotu.

00:03:24.470 --> 00:03:29.030
Ale my naprawdę zwracamy coś ponownie.

00:03:29.190 --> 00:03:33.970
Dostajemy tę dobrą wskazówkę od maszynopisu i naszego redaktora.

00:03:34.140 --> 00:03:40.160
Więc jeśli zwrócisz la la, mogę po prostu napisać ciąg i wszystko działa.

00:03:40.350 --> 00:03:43.080
Ale zachowajmy to tak, jak było.

00:03:43.080 --> 00:03:46.490
Używanie void dla dowolnej funkcji, która niczego nie zwraca.

00:03:47.960 --> 00:03:55.510
Jest też jeszcze jeden rodzaj, który pozwoli nam zrobić więcej przestrzeni nigdy.

00:03:55.520 --> 00:03:56.300
Teraz jest to trudne.

00:03:56.300 --> 00:03:59.140
Jak myślisz, co robi?

00:03:59.150 --> 00:04:14.780
Pozwól, że pokażę ci za pomocą kodu, że możemy powiedzieć dużo ERA Równy funkcji powietrza, która po prostu wyrzuca powietrze, jeśli uratowałem to

00:04:20.840 --> 00:04:31.520
nic się nie dzieje, ale jeśli dam mu literówkę, nigdy nie wiesz, że to mija.

00:04:31.570 --> 00:04:33.280
Więc uznajemy, że rodzaj.

00:04:33.280 --> 00:04:38.350
Nigdy, jeśli tego nie zrobię, nadal działa, ponieważ nic nie zwracamy.

00:04:38.390 --> 00:04:43.580
Ale jeśli zrobię coś w rodzaju struny, to też działa.

00:04:44.120 --> 00:04:46.110
Więc, co to znaczy.

00:04:47.020 --> 00:04:50.060
Nigdy nie wpisuj faktycznie testuje dwie rzeczy.

00:04:50.110 --> 00:04:58.850
Jednym z nich jest to, że funkcja nigdy nie wraca, a druga to taka, że bardzo zmienna pod jakimś typem

00:04:58.860 --> 00:05:01.370
Guard nigdy nie jest prawdziwa.

00:05:02.890 --> 00:05:10.120
Na przykład w naszym przypadku, gdy wyrzucamy błąd maszynopisów, nigdy nie wpisujemy, ponieważ funkcja

00:05:10.150 --> 00:05:15.120
nie ma ani typu zwracanego, ani osiągalnego punktu końcowego.

00:05:15.370 --> 00:05:17.080
To działa.

00:05:17.230 --> 00:05:27.300
A jeśli powrócę Witam i Icesave, otrzymam błąd, dostaniemy możliwego do wykonania kodu ARM.

00:05:27.670 --> 00:05:39.220
Ale jeśli to przyniosę lub zatrzymam się, upewnijmy się, że nigdy tego nie zrobimy i nie oszczędzamy, i widzimy, że otrzymujemy dwa błędy

00:05:39.670 --> 00:05:47.350
jeden dla naszego osiągalnego kodu, który nie ma sensu i nie można przypisać typu pelo.

00:05:47.380 --> 00:05:48.410
Nigdy.

00:05:48.760 --> 00:05:52.890
Jeśli to skomentuję i zapiszę ponownie, dostaję ten błąd.

00:05:53.230 --> 00:05:56.530
Ponownie, ponieważ zwracamy coś,

00:05:59.510 --> 00:06:04.800
wróćmy do rzeczywistości i wszystko się właściwie kompiluje.

00:06:04.830 --> 00:06:07.470
Być może zastanawiasz się, co jeśli

00:06:10.350 --> 00:06:17.670
wstawię Nigdy tutaj, widzimy, że funkcja zwracana powracająca nigdy nie może mieć osiągalnego punktu końcowego, ponieważ ta funkcja działa

00:06:18.950 --> 00:06:23.620
i ma punkt końcowy do zrobienia dziennika Konsole, a następnie się kończy.

00:06:23.870 --> 00:06:32.060
Tak więc pamiętaj, że nigdy nie jest dla funkcji, która nie zwraca i nie ma tego punktu końcowego

00:06:32.060 --> 00:06:33.610
zwykle zgłasza błąd.

00:06:33.620 --> 00:06:35.320
W porządku, to tyle na teraz.

00:06:35.510 --> 00:06:37.940
Więcej rodzajów w następnym wideo.

00:06:38.200 --> 00:06:38.440
Buh-Bye.